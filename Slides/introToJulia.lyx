#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass beamer
\begin_preamble
\usetheme{Frankfurt}
\setbeamertemplate{footline}[frame number]

% One way to customize the footline
% Adapted from Dr. Rostamian's UMBC themes
\newcommand{\myfootline}{%
  \insertshortauthor
  \hfill
  \insertshortinstitute
  \hfill
  \insertframenumber/\inserttotalframenumber}

\setbeamertemplate{footline}{%
  \usebeamerfont{structure}
  \begin{beamercolorbox}[wd=\paperwidth,ht=2.25ex,dp=1ex]{palette secondary}%
    \Tiny\hspace*{4mm}\myfootline\hspace{4mm}
  \end{beamercolorbox}}
% Finised customizing footline

% Get rid of the navigation symbols
\setbeamertemplate{navigation symbols}{}
\end_preamble
\use_default_options true
\begin_modules
listings
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
A Nontrivial Introduction to Julia
\begin_inset Newline newline
\end_inset

For Data Science and Scientific Computing
\end_layout

\begin_layout Author
Chris Rackauckas
\end_layout

\begin_layout Institute
University of California, Irvine
\end_layout

\begin_layout Section
Outline
\end_layout

\begin_layout Subsection
Quick Introduction
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Quick Introduction
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Third Year Math Ph.D student from MCSB.
\end_layout

\begin_layout Itemize
Main interest: stochastic analysis in theoretical (evo-) developmental biology.
\end_layout

\begin_deeper
\begin_layout Itemize
Stochastic analysis: stochastic/nonautonomous dynamical systems and numerical
 methods
\end_layout

\begin_layout Itemize
Focus on developmental signaling and cell lineages
\end_layout

\end_deeper
\begin_layout Itemize
High-Performance Computing and Stats / Machine Learning.
\end_layout

\begin_layout Itemize
I run a blog on mathematics and scientific computing: 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.stochasticlifestyle.com/
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Notes About the Workshop
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Notes About the Workshop
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
I expect that you have knowledge of some programming or scripting language.
\end_layout

\begin_layout Itemize

\color blue
Advanced topics will be colored blue
\end_layout

\begin_deeper
\begin_layout Itemize
I do not expect everyone to get everything
\end_layout

\begin_layout Itemize
I think it's important to expose the 
\begin_inset Quotes eld
\end_inset

lingo
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Julia can get very low level and 
\begin_inset Quotes eld
\end_inset

CSy
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
I will focus on the path from scripting downwards
\end_layout

\end_deeper
\begin_layout Itemize
The projects give help for how to get started, but you will need to use
 the documentation
\end_layout

\begin_deeper
\begin_layout Itemize
The ultimate goal is that you will learn how to use the documentation /
 Github / mailing lists / Gitter to get things done in Julia
\end_layout

\begin_layout Itemize
Since Julia is so young, you cannot expect to get 
\begin_inset Quotes eld
\end_inset

free code
\begin_inset Quotes erd
\end_inset

 from Stack Exchange all the time!
\end_layout

\end_deeper
\begin_layout Itemize
Do not be afraid to ask questions
\end_layout

\begin_layout Itemize
Take your time with the projects, help each other
\end_layout

\end_deeper
\begin_layout Subsection
Outline
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Outline
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Getting Started in Julia
\end_layout

\begin_deeper
\begin_layout Enumerate
Why Julia? When to choose Julia?
\end_layout

\begin_layout Enumerate
Installing/Building Julia and setting up an IDE
\end_layout

\begin_layout Enumerate
The package management system / Github
\end_layout

\begin_layout Enumerate
Basic usage: control statements, types, functions
\end_layout

\begin_layout Enumerate
Where to get help: documentation, message boards, etc.
\end_layout

\end_deeper
\begin_layout Enumerate
Syntax / terminology plus some innards of Julia
\end_layout

\begin_deeper
\begin_layout Enumerate
Differences from other common languages
\end_layout

\begin_layout Enumerate
Unique Programming Paradigms of Julia
\end_layout

\begin_deeper
\begin_layout Enumerate
Linear Algebra
\end_layout

\begin_layout Enumerate
Data-Oriented Programming
\end_layout

\begin_layout Enumerate
Macro Programming
\end_layout

\begin_layout Enumerate
Levels of Parallelization
\end_layout

\begin_layout Enumerate
De-vectorization, SIMD, threading, parallelization
\end_layout

\begin_layout Enumerate
Named Functions
\end_layout

\begin_layout Enumerate
Subscoping
\end_layout

\begin_layout Enumerate
LLVM
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Subsection
Additional Topics
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Additional Topics
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Extra Projects
\end_layout

\begin_deeper
\begin_layout Enumerate
Mathematical Modeling / Dynamical Systems
\end_layout

\begin_layout Enumerate
Data Visualization
\end_layout

\begin_layout Enumerate
Multi-Node HPC (Julia's 
\begin_inset Quotes eld
\end_inset

MPI
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Enumerate
Interal Investigations
\end_layout

\begin_layout Enumerate
Modules and Packages
\end_layout

\begin_layout Enumerate
Language Bindings
\end_layout

\begin_layout Enumerate
Data Saving and Serialization
\end_layout

\end_deeper
\begin_layout Enumerate
Additional Topics
\end_layout

\begin_deeper
\begin_layout Enumerate
Generated Functions
\end_layout

\begin_layout Enumerate
Optimization / Machine Learning
\end_layout

\begin_layout Enumerate
GPGPU / Xeon Phi computing 
\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Getting Started in Julia
\end_layout

\begin_layout Subsection
Why Julia?
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why Julia?
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The purpose of Julia is to solve the 
\begin_inset Quotes eld
\end_inset

multiple-language problem of scientific computing
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
MATLAB -> MEX, Python -> Cython, R -> ???
\end_layout

\begin_layout Itemize
These languages require vectorization or C
\end_layout

\end_deeper
\begin_layout Itemize
Another way to think about Julia: It's the 2015 idea of a good programming
 language:
\end_layout

\begin_deeper
\begin_layout Itemize
MATLAB (1984), Python (1991), R (1993), Java (1995), C (1973), Lisp (1958)
\end_layout

\begin_layout Itemize
Scripting and vectorization is succinct for scientific programs
\end_layout

\begin_layout Itemize
JIT compilation works really well (Javascript)
\end_layout

\begin_layout Itemize
Object-oriented programming has some good ideas
\end_layout

\begin_layout Itemize
Functional/Meta programming is very useful for some tasks
\end_layout

\begin_layout Itemize
All the other things you learned in a CS course
\end_layout

\end_deeper
\begin_layout Itemize
Result: Julia is an LLVM-based JIT compiled language that looks like MATLAB/Pyth
on/R, but contains all the fancy guts you learned in computer science
\end_layout

\end_deeper
\begin_layout Subsection
When to use Julia?
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
When to Use Julia?
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Everyday scientific computing / data science scripting
\end_layout

\begin_deeper
\begin_layout Itemize
The best language for scripts which will need to be optimized
\end_layout

\end_deeper
\begin_layout Itemize

\color blue
Library creation for scientific computing
\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
Numerical / High-performance computing libraries
\end_layout

\begin_layout Itemize

\color blue
Exploit 
\begin_inset Quotes eld
\end_inset

Vectorization
\begin_inset Quotes erd
\end_inset

 style of scientific scripting
\end_layout

\end_deeper
\begin_layout Itemize

\color blue
To speed production of things you would have done in C
\end_layout

\begin_layout Itemize
Best optimization, machine learning, automatic differentiation, stochastic
 differential equations and more packages
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Data-oriented programming
\begin_inset Quotes erd
\end_inset

 structure for readability
\end_layout

\begin_layout Itemize
Unicode symbols like 
\begin_inset Formula $\alpha$
\end_inset

 to enhance readability
\end_layout

\begin_layout Itemize
Replace MATLAB codes for HPCs due to licensing issues
\end_layout

\begin_layout Itemize
Use R / Python / C / MATLAB packages in one language
\end_layout

\begin_layout Itemize

\color red
The Cons of Julia
\end_layout

\begin_deeper
\begin_layout Itemize

\color red
It's still new and rapidly evolving
\end_layout

\begin_layout Itemize

\color red
Because of the advanced features, it's seems like it's not as beginner friendly
 as other scripting languages
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
The Users of Julia
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The Users of Julia
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
People who want scripts to be easily optimized to run fast
\end_layout

\begin_layout Enumerate
People who want to use fast packages/libraries written in Julia
\end_layout

\begin_layout Enumerate
People that need to bind together many different languages
\end_layout

\begin_layout Enumerate
People who want to use HPC/multi-node parallelism/GPGPU/Xeon Phi w/o OpenMP,
 MPI, CUDA...
\end_layout

\begin_deeper
\begin_layout Enumerate
People who want to use 
\begin_inset Quotes eld
\end_inset

Big Data
\begin_inset Quotes erd
\end_inset

 
\color blue
(distributed/shared arrays)
\end_layout

\end_deeper
\begin_layout Enumerate

\color blue
People who want to write optimized packages/libraries but want the fast
 development time of a scripting language
\end_layout

\begin_deeper
\begin_layout Enumerate

\color blue
Making 
\begin_inset Quotes eld
\end_inset

libraries for scripters
\begin_inset Quotes erd
\end_inset

 that overwrite base function for automatic speedups (i.e.
 VML.jl, Devec.jl, ParallelAccelerator.jl) 
\end_layout

\end_deeper
\begin_layout Enumerate

\color blue
People who want to mix procedural and functional programming styles
\end_layout

\begin_deeper
\begin_layout Enumerate

\color blue
Writing compilers in Julia (i.e.
 ParallelAccelerator.jl)
\end_layout

\end_deeper
\begin_layout Enumerate
Everybody!
\end_layout

\end_deeper
\begin_layout Subsection
Example of a Julia Success: ParallelAccelerator.jl
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example of a Julia Success: ParallelAccelerator.jl
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
ParallelAccelerator.jl started in June 2015
\end_layout

\begin_layout Itemize
It is made and maintained by 6 people from IntelLabs
\end_layout

\begin_deeper
\begin_layout Itemize
It is a compiler written in Julia
\end_layout

\begin_layout Itemize
It takes standard scripting code (
\begin_inset Quotes eld
\end_inset

vectorized
\begin_inset Quotes erd
\end_inset

) and 
\begin_inset Quotes eld
\end_inset

does the optimizations an expert C++ coder would do
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
Eliminates array bounds checking
\end_layout

\begin_layout Itemize

\color blue
Vectorizes to use SIMD / threading
\end_layout

\begin_layout Itemize

\color blue
Controls the caching
\end_layout

\begin_layout Itemize
Many other things I may not understand
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
To use it, just add 
\begin_inset Quotes eld
\end_inset

@acc
\begin_inset Quotes erd
\end_inset

 to the front of a function
\end_layout

\begin_deeper
\begin_layout Itemize
Users don't have to know why it works to get a MASSIVE (20x+) speedup
\end_layout

\begin_layout Itemize

\color blue
Can automatically compile code for Xeon Phi.
 May target OpenACC in the future for GPGPU
\end_layout

\end_deeper
\begin_layout Standard
Summary: Written in Julia to speed up Julia code.
 Users don't have to change their code to use it.
\end_layout

\end_deeper
\begin_layout Subsection
Building / Installing Julia
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Building / Installing Julia
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The easiest way to get started is to use the Current Release from julialang.org
\end_layout

\begin_layout Itemize
Note: for heavy language users you 
\begin_inset Quotes eld
\end_inset

may
\begin_inset Quotes erd
\end_inset

 want to get the nightly builds
\end_layout

\begin_deeper
\begin_layout Itemize
As of March 2016, the nightly build is V0.5 which includes threading
\end_layout

\end_deeper
\begin_layout Itemize

\color blue
The other option is to build Julia:
\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
GCC version 4.7 or later is required to build Julia
\end_layout

\begin_layout Itemize

\color blue
The default compiler on CentOS / RHEL (gcc 4.4) is too old to build Julia
\end_layout

\begin_layout Itemize

\color blue
For large systems (HPC nodes) you will want to increase the number of BLAS
 threads
\end_layout

\begin_layout Itemize

\color blue
Instructions for linking with MKL are found on the Julia Github
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Integrated Development Environments
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Integrated Development Environments
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
As of February 2016, the recommended IDE is Atom
\end_layout

\begin_deeper
\begin_layout Itemize
The previous IDE, Juno via Light Table was dropped since Light Table is
 no longer maintained
\end_layout

\begin_layout Itemize
The Juno team is now actively developing Atom.jl, Blink.jl, ink, atom-julia-client
\end_layout

\begin_layout Itemize
Julia with Atom is similar to Rstudio / MATLAB
\end_layout

\end_deeper
\begin_layout Itemize

\color blue
Other popular IDEs:
\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
IJulia (browser)
\end_layout

\begin_layout Itemize

\color blue
Sublime Text with IJulia
\end_layout

\begin_layout Itemize

\color blue
vim, emacs, etc.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Example Julia Code
\end_layout

\begin_layout FragileFrame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example Julia Code
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

matrix = [1 2 3 4
\end_layout

\begin_layout Plain Layout

          3 4 5 6
\end_layout

\begin_layout Plain Layout

          4 4 4 6
\end_layout

\begin_layout Plain Layout

          3 3 3 3] #Define the matrix
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f(x,y) = 2x+y #Create an inline function
\end_layout

\begin_layout Plain Layout

@time for i=1:4,j=1:4 #Two loops in one command
\end_layout

\begin_layout Plain Layout

  #update matrix[i,j] = matrix[i,j] + f(i,j)
\end_layout

\begin_layout Plain Layout

  matrix[i,j] += f(i,j) 
\end_layout

\begin_layout Plain Layout

end #end statement is required for control statements like for
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Pkg.add("ASCIIPlots") #Only use the first time!
\end_layout

\begin_layout Plain Layout

using ASCIIPlots #Load the package
\end_layout

\begin_layout Plain Layout

scatterplot(1:4,matrix[end,:],sym='*') #Plot the last row
\end_layout

\begin_layout Plain Layout

scatterplot(1:4,matrix[2,:],sym='^') #Plot the second row
\end_layout

\begin_layout Plain Layout

package = "ASCIIPlots" #Define a string
\end_layout

\begin_layout Plain Layout

println("$package is a super cool package") #Print a string
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout FragileFrame

\end_layout

\begin_layout FragileFrame

\end_layout

\begin_layout Subsection
Example Output
\end_layout

\begin_layout FragileFrame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example Output
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily}"
inline false
status open

\begin_layout Plain Layout

0.002328 seconds (82 allocations: 5.281 KB) #Timing result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

julia> scatterplot(1:4,matrix[2,:],sym='^') #Plot the second row
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        -------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

        |                                                          ^ | 14.00
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                       ^                    |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                   ^                                        |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |                                                            |
\end_layout

\begin_layout Plain Layout

        |^                                                           | 8.00
\end_layout

\begin_layout Plain Layout

        -------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

        1.00                                                    4.00
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

julia> println("$package is a super cool package") #Print a string
\end_layout

\begin_layout Plain Layout

ASCIIPlots is a super cool package
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Basic Types of Julia
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Basic Types of Julia
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A Vector is a one-dimensional array
\end_layout

\begin_layout Itemize
An Array{Type,2}(n,m) is an 
\begin_inset Formula $n\times m$
\end_inset

 array of types
\end_layout

\begin_layout Itemize
\begin_inset Formula $1:n$
\end_inset

 forms a 
\begin_inset Quotes eld
\end_inset

Range type
\begin_inset Quotes erd
\end_inset

 which can be thought of as the vector 
\begin_inset Formula $[1,2,\ldots,n]$
\end_inset

.
\end_layout

\begin_layout Itemize
A dictionary Dict is a key-value structure
\end_layout

\begin_layout Itemize
A tuple is an immutable structure
\end_layout

\begin_deeper
\begin_layout Itemize
Used for multiple return values
\end_layout

\begin_layout Itemize
Very computationally efficient!
\end_layout

\end_deeper
\begin_layout Itemize

\color blue
A function is also a type
\end_layout

\end_deeper
\begin_layout Subsection
Example Usage of Julia Types
\end_layout

\begin_layout FragileFrame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example Usage of Julia Types
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

ran = 1:5 #Define a range
\end_layout

\begin_layout Plain Layout

vec = collect(ran) #Turn the range into a vector
\end_layout

\begin_layout Plain Layout

vec2=Vector{Float64}(2) #Define a size 2 vector of 64-bit floats
\end_layout

\begin_layout Plain Layout

vec2[1]=2; vec2[2]=3   # vec2 = [2,3], ; allows multiple commands
\end_layout

\begin_layout Plain Layout

push!(vec2,5) # vec2 = [2,5]
\end_layout

\begin_layout Plain Layout

mat = Array{Int64,2}(5,5) # Create an empty 5x5 matrix
\end_layout

\begin_layout Plain Layout

mat2 = ones(5,5) #Create a 5x5 matrix of ones
\end_layout

\begin_layout Plain Layout

Q,R = qr(mat2) #QR decompose mat2 (returns a tuple) into Q and R
\end_layout

\begin_layout Plain Layout

tup = ran,vec,vec2 #Define a tuple of many different objects
\end_layout

\begin_layout Plain Layout

tup[2] #This returns vec
\end_layout

\begin_layout Plain Layout

dict = Dict("a" => 1, "b" => 2, "c" => 3) #Define a dictionary
\end_layout

\begin_layout Plain Layout

dict["a"] #Returns 1
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout FragileFrame

\end_layout

\begin_layout Subsection
Defining Functions
\end_layout

\begin_layout FragileFrame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Defining Functions
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function testFunction(x,y;z=0) #z is an optional argument
\end_layout

\begin_layout Plain Layout

  if z==0
\end_layout

\begin_layout Plain Layout

    return x+y,x*y #Return a tuple
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

  return x*y*z,x+y+z #Return a different tuple
\end_layout

\begin_layout Plain Layout

  #whitespace is optional
\end_layout

\begin_layout Plain Layout

  end #End if statement
\end_layout

\begin_layout Plain Layout

end #End function definition
\end_layout

\begin_layout Plain Layout

a,b = testFunction(2,2) #Returns 4,4
\end_layout

\begin_layout Plain Layout

a2,b2 = testFunction(2,3,z=3) #Returns 18,8
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
The Package Management System
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The Package Management System
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Julia's package management system is Github
\end_layout

\begin_deeper
\begin_layout Itemize
The packages are hosted as Github repositories
\end_layout

\begin_layout Itemize
Julia packages are normally referred to with the ending 
\begin_inset Quotes eld
\end_inset

.jl
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Repositories register to become part of the central package management by
 sending a pull request to METADATA.jl
\end_layout

\end_deeper
\begin_layout Itemize
The packages can be found / investigated at Github.com
\end_layout

\begin_deeper
\begin_layout Itemize
Julia's error messages are hyperlinks to the page in Github
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
A Very Quick Introduction to Git/Github
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
A Very Quick Introduction to Git/Github
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Git is a common Version Control System (VCS)
\end_layout

\begin_layout Itemize
A project is a 
\series bold
repository (repos)
\end_layout

\begin_layout Itemize
After one makes changes to a project, 
\series bold
commit
\series default
 the changes
\end_layout

\begin_layout Itemize
Changes are 
\series bold
pulled 
\series default
to the main repository
\series bold
 
\series default
hosted online
\end_layout

\begin_layout Itemize
To download the code, you 
\series bold
clone
\series default
 the repository
\end_layout

\begin_layout Itemize
Instead of editing the main repository, one edits a 
\series bold
branch
\end_layout

\begin_deeper
\begin_layout Itemize
To get the changes of the main branch in yours, you 
\series bold
fetch
\end_layout

\begin_layout Itemize
One asks the owner of the repository to add their changes via a 
\series bold
pull request
\end_layout

\end_deeper
\begin_layout Itemize
Stable versions are cut to 
\series bold
releases
\end_layout

\begin_layout Itemize
The major online server for git repositories is Github
\end_layout

\begin_layout Itemize
Github is a free service
\end_layout

\begin_layout Itemize
Anyone can get a Github account
\end_layout

\begin_layout Itemize
The code is hosted online, free for everyone to view
\end_layout

\begin_layout Itemize
Users can open 
\series bold
Issues 
\series default
to ask for features and give bug reports to developers
\end_layout

\end_deeper
\begin_layout Subsection
Using Julia's Package Management System
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Using Julia's Package Management System
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Standard Usage
\end_layout

\begin_deeper
\begin_layout Itemize
Pkg.add(
\begin_inset Quotes eld
\end_inset

Package
\begin_inset Quotes erd
\end_inset

) clones the repo of the package to your system
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

using Package
\begin_inset Quotes erd
\end_inset

 imports the package for use in your code
\end_layout

\begin_layout Itemize
Pkg.update() fetches releases from METADATA.jl
\end_layout

\end_deeper
\begin_layout Itemize
Advanced Usage
\end_layout

\begin_deeper
\begin_layout Itemize
Pkg.build(
\begin_inset Quotes eld
\end_inset

Package
\begin_inset Quotes erd
\end_inset

) re-compiles a package (if compilation failed)
\end_layout

\begin_layout Itemize
Pkg.checkout(
\begin_inset Quotes eld
\end_inset

Package
\begin_inset Quotes erd
\end_inset

,branch) checks out the branch (default: main)
\end_layout

\begin_layout Itemize

\color blue
Pkg.pin(
\begin_inset Quotes eld
\end_inset

Package
\begin_inset Quotes erd
\end_inset

) keeps the package at a specific version / commit
\end_layout

\begin_layout Itemize

\color blue
Pkg.test(
\begin_inset Quotes eld
\end_inset

Package
\begin_inset Quotes erd
\end_inset

) runs the Travis CL unit tests
\end_layout

\end_deeper
\begin_layout Itemize

\color blue
The tools for generating, tagging, and publishing a package exist within
 Julia
\end_layout

\end_deeper
\begin_layout Subsection
Julia's Documentation
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Julia's Documentation
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Julia has a standard inline documentation system which is supported by Read
 the Docs
\end_layout

\begin_layout Itemize
Functions (not methods) are documented in this API by their input/output
\end_layout

\begin_layout Itemize
Optional function arguments are denoted by (...)
\end_layout

\end_deeper
\begin_layout Subsection
Project 1: Setup and Using Packages/Documentation
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Project 1: Setup and Using Packages/Documentation
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Get an IDE up and running
\end_layout

\begin_layout Itemize
Install the package Winston
\end_layout

\begin_layout Itemize
Go to the Github page and find the documentation
\end_layout

\begin_layout Itemize
Plot the example Stem plot
\end_layout

\begin_layout Itemize
Find the code where Stems is defined
\end_layout

\begin_layout Itemize
Search the issues for 
\begin_inset Quotes eld
\end_inset

Error when using Gadfly
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Change to JeffBezanson's Working branch
\end_layout

\begin_layout Itemize
Now look at the other plotting package Gadfly:
\end_layout

\begin_deeper
\begin_layout Itemize
Find the Travis CI test coverage percentage
\end_layout

\begin_layout Itemize
Take a look at the Gitter chat
\end_layout

\end_deeper
\begin_layout Itemize
Go to Google Groups-Julia-users, search for posts about Gadfly
\end_layout

\begin_deeper
\begin_layout Itemize
What are the names of the people who seem to answer all of the questions?
\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Introduction to Syntax / Terminology
\end_layout

\begin_layout Subsection
Main Differences from Other Languages
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Main Differences from Other Languages
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://docs.julialang.org/en/release-0.4/manual/noteworthy-differences/
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Julia uses 1-based indexing
\end_layout

\begin_layout Itemize

\color blue
A vector of 1 slot is not a scalar
\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
Vector{Type}(size), 1:N, Float64, etc.
 are 
\series bold
Types
\end_layout

\begin_layout Itemize

\color blue
User types and functions are 
\series bold
first-class
\end_layout

\end_deeper
\begin_layout Itemize
A variable can hold a function (named functions)
\end_layout

\begin_layout Itemize
2-dimensional arrays are treated as matrices
\end_layout

\begin_deeper
\begin_layout Itemize
* is matrix multiplication, A
\backslash
b solves Ax=b
\end_layout

\begin_deeper
\begin_layout Itemize
These operations are implemented in BLAS, Linpack
\end_layout

\end_deeper
\begin_layout Itemize
.*, .+, .>, etc.
 perform element-wise operations
\end_layout

\end_deeper
\begin_layout Itemize
Arrays are dereferenced and constructed with [] (i.e.
 A[i])
\end_layout

\end_deeper
\begin_layout Subsection
Programming Paradigms of Juila 1: Linear Algebra
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Programming Paradigms of Julia 1: Linear Algebra
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Linear algebra is central to scientific computing and Julia
\end_layout

\begin_layout Itemize
Julia's linear algebra syntax follows MATLAB's closely.
\end_layout

\begin_deeper
\begin_layout Itemize
For lots of linear algebra you can use MATLAB's documentation
\end_layout

\end_deeper
\begin_layout Itemize
Julia's linear algebra documentation is split between two pages:
\end_layout

\begin_deeper
\begin_layout Itemize
Multi-dimensional arrays: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://docs.julialang.org/en/release-0.4/manual/arrays/
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Linear algebra: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://docs.julialang.org/en/release-0.4/manual/linear-algebra/
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Project 2: Linear Algebra
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Project 2: Linear Algebra
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Use the following documentation page: 
\end_layout

\begin_layout Itemize
Take two 
\begin_inset Formula $N\times N$
\end_inset

 random matrices, 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Itemize
Compute 
\begin_inset Formula $C=AB$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

, the Hadamard product of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 (
\begin_inset Formula $A.*B$
\end_inset

)
\end_layout

\begin_layout Itemize
Compute the maximum and 
\begin_inset Formula $2$
\end_inset

-norm of the last column of 
\begin_inset Formula $C-D$
\end_inset

.
\end_layout

\begin_layout Itemize
Make the 
\begin_inset Formula $2N\times N$
\end_inset

 matrix which is 
\begin_inset Formula $C$
\end_inset

 concatenated on top of 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Itemize
Find the SVD-decomposition of 
\begin_inset Formula $D$
\end_inset

 and plot the singular-value matrix
\end_layout

\begin_layout Itemize

\color blue
Set blas_num_threads to different values and check the performance (parallelizat
ion) of 
\begin_inset Formula $A*B$
\end_inset

.
\end_layout

\begin_layout Itemize

\color blue
Create a 100x100 sparse diagonal matrix with 
\begin_inset Formula $-2,1,-2,1...$
\end_inset

 on the diagonal 
\end_layout

\end_deeper
\begin_layout Subsection
Programming Paradigms of Julia 2: 
\begin_inset Quotes eld
\end_inset

Data-Oriented
\begin_inset Quotes erd
\end_inset

 Programming
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Programming Paradigms of Julia 2: 
\begin_inset Quotes eld
\end_inset

Data-Oriented
\begin_inset Quotes erd
\end_inset

 Programming
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
Julia does not implement a 
\begin_inset Quotes eld
\end_inset

full object-oriented
\begin_inset Quotes erd
\end_inset

 paradigm
\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
There is no inheritance, encapsolation (except with Modules), and 
\begin_inset Quotes eld
\end_inset

data-owned methods
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\series bold
This is intentional and it will stay this way
\end_layout

\end_deeper
\begin_layout Itemize
However, types and multiple dispatch allow for a 
\begin_inset Quotes eld
\end_inset

Data-Oriented
\begin_inset Quotes erd
\end_inset

 structure
\end_layout

\begin_deeper
\begin_layout Itemize

\size scriptsize
\color blue
You can think of types as being objects
\end_layout

\begin_layout Itemize

\series bold
\size scriptsize
Functions
\series default
 call different 
\series bold
methods
\series default
 depending on the type given
\end_layout

\begin_deeper
\begin_layout Itemize

\size scriptsize
This is called multiple dispatch
\end_layout

\begin_layout Itemize

\size scriptsize
\color blue
Functions are a type whose fields are methods
\end_layout

\end_deeper
\begin_layout Itemize

\size scriptsize
\color blue
User types are first class
\end_layout

\begin_deeper
\begin_layout Itemize

\size scriptsize
\color blue
Types can have a field which is another type, allowing for a form of inheritance
\end_layout

\end_deeper
\begin_layout Itemize

\size scriptsize
Standard types include Float64, Vector{Type}, Array{dim,Type}, 
\series bold
Any,
\series default
 Dataframe ...
\end_layout

\begin_deeper
\begin_layout Itemize

\size scriptsize
Functions which take in Any will compile at runtime for the type that it
 is given
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Subsection
Project 3: 
\begin_inset Quotes eld
\end_inset

Data-Oriented
\begin_inset Quotes erd
\end_inset

 Programming
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Project 3: 
\begin_inset Quotes eld
\end_inset

Data-Oriented
\begin_inset Quotes erd
\end_inset

 Programming
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Construct a function 
\series bold
solve 
\series default
which takes in a matrix 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $x_{0}$
\end_inset

 and iterates 
\begin_inset Formula $x_{n+1}=Ax_{n}+\epsilon_{n}$
\end_inset

, 
\begin_inset Formula $\epsilon\sim N(0,1)$
\end_inset

.
\end_layout

\begin_layout Itemize
Construct a type called 
\series bold
model 
\series default
which holds a matrix 
\begin_inset Formula $A$
\end_inset

 and a vector 
\begin_inset Formula $x_{0}$
\end_inset

.
\end_layout

\begin_layout Itemize
Create a new method for the solve function which takes in a model and solves
 it 100 times and returns the mean and variance
\end_layout

\begin_layout Itemize
Create a new type called 
\series bold
ParameterSweep 
\series default
which holds a vector of models
\end_layout

\begin_layout Itemize
Create a new method for the solve function which takes in a parameter sweep
 and returns a vector of tuples with 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $x_{0}$
\end_inset

, mean, and variance
\end_layout

\end_deeper
\begin_layout Subsection
Programming Paradigms of Julia 3: 
\begin_inset Quotes eld
\end_inset

Macro
\begin_inset Quotes erd
\end_inset

 Programming
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Programming Paradigms of Julia 3: 
\begin_inset Quotes eld
\end_inset

Macro
\begin_inset Quotes erd
\end_inset

 Programming
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
Macros are implemented by the parser pre-compilation
\end_layout

\begin_deeper
\begin_layout Itemize
Macros are methods for metaprogramming: programming the program
\end_layout

\end_deeper
\begin_layout Itemize
Macros can be used to 
\begin_inset Quotes eld
\end_inset

expand
\begin_inset Quotes erd
\end_inset

 simple code into more complex code, while maintaining the simple code for
 readability
\end_layout

\begin_layout Itemize
Common macros: @time, @elapsed, @parallel, @devec, @simd, @nobounds, @thread
\end_layout

\begin_layout Itemize
Macros can block via: @macro begin #codecodecode end
\end_layout

\begin_layout Itemize

\color blue
Users can write their own macros to avoid having to do repetative programming
 tasks.
\end_layout

\end_deeper
\begin_layout Subsection
Project 4: Using Macros
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Project 4: Using Macros
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Write functions which take 
\begin_inset Formula $N$
\end_inset

, generates uniformly distributed 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

, and 
\begin_inset Formula $D$
\end_inset

 and solves 
\begin_inset Formula $A.*B.*C.*D$
\end_inset

 in three ways:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A.*B.*C.*D$
\end_inset


\end_layout

\begin_layout Itemize
A for loop
\end_layout

\begin_layout Itemize
A for loop with @simd, @nobounds
\end_layout

\begin_layout Itemize
\begin_inset Formula $A.*B.*C.*D$
\end_inset

 with @devec
\end_layout

\end_deeper
\begin_layout Itemize
Time the functions using tic() and toc()
\end_layout

\begin_layout Itemize
Time the functions with @time
\end_layout

\begin_layout Itemize
Use @elapsed to time the functions and save the values to a variable
\end_layout

\begin_deeper
\begin_layout Itemize
Some of your first runs will be weird (the longest!).
 How can you fix this? Can you find out why this happened?
\end_layout

\end_deeper
\begin_layout Itemize
Use @benchmark / @benchmarks 
\color blue
(Extra: Try ParallelAccelerator.jl)
\end_layout

\begin_layout Itemize
Find out what the native Julia implementation is for 
\begin_inset Formula $.*$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Can you explain why devectorization is fastest?
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Levels of Parallelization
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Levels of Parallelization
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
SIMD parallelization is 
\begin_inset Quotes eld
\end_inset

processor-level parallelization
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The package is developed by Intel
\end_layout

\begin_layout Itemize

\color blue
It uses the processor's AVX (Advanced Vector Extensions)
\end_layout

\begin_deeper
\begin_layout Itemize
The compute cores can process more than 1 number at a time!
\end_layout

\end_deeper
\begin_layout Itemize
Add @simd to the beginning of an inner loop
\end_layout

\begin_deeper
\begin_layout Itemize
The values must be able to be re-ordered
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Thread parallelization is shared-memory parallelization
\end_layout

\begin_deeper
\begin_layout Itemize
Threads share the memory on the same computer
\end_layout

\begin_layout Itemize
Use @thread at the beginning of a threadable loop
\end_layout

\end_deeper
\begin_layout Itemize
Task parallelization is a general form of parallelization
\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
Much easier than MPI, though the same capabilities
\end_layout

\begin_deeper
\begin_layout Itemize
Can be used on multiple compute nodes on an HPC
\end_layout

\end_deeper
\begin_layout Itemize
Memory is not shared, items have to be distributed and passed
\end_layout

\begin_layout Itemize

\color blue
Either open julia with -p numberOfProcs 
\color inherit
or use addprocs(n)
\end_layout

\begin_deeper
\begin_layout Itemize
One process is the control process, the others are workers
\end_layout

\end_deeper
\begin_layout Itemize
Use @parallel, pmap, etc.
 to distribute work to the workers
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Programming Paradigms of Julia 3: Named Functions
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Programming Paradigms of Julia 3: Named Functions
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
User functions are first-class in Julia
\end_layout

\begin_deeper
\begin_layout Itemize
This means that they can be modified like base functions
\end_layout

\end_deeper
\begin_layout Itemize
Julia functions can be named, allowing inline function definitions
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\nabla f(x)=5x$
\end_inset

 is a valid function definition
\end_layout

\end_deeper
\begin_layout Itemize
This can be useful for defining 
\begin_inset Quotes eld
\end_inset

subfunctions
\begin_inset Quotes erd
\end_inset

 which perform a repetative task.
\end_layout

\begin_layout Itemize

\color blue
Base functions can be overloaded with new functionality
\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
Packages can use this to make 
\begin_inset Quotes eld
\end_inset

fast
\begin_inset Quotes erd
\end_inset

 versions
\end_layout

\begin_layout Itemize

\color blue
Example: VML.jl 
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Project 5: Named Functions
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Project 5: Named Functions
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Extend the code from project 4 using Vector{Float64}(0) and push! to get
 the timings of 
\begin_inset Formula $A.*B.*C.*D$
\end_inset

 for 
\begin_inset Formula $N=2^{n}$
\end_inset

 with 
\begin_inset Formula $n=1:10$
\end_inset

.
\end_layout

\begin_layout Itemize
Write a line of code which takes the array of times to produce a plot via
 Gadfly.
\end_layout

\begin_layout Itemize
Extend this to an inline function plotTimes(timeArr,titStr) which takes
 in a time array and a titStr and produces the appropriate plot.
\end_layout

\begin_layout Itemize
Use this function to plot the timings.
\end_layout

\begin_layout Itemize
Extend the plotting function to take in 4 arrays and plot them on the same
 graph using 
\begin_inset Quotes eld
\end_inset

layer()
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Programming Paradigms of Julia 4: Subscoping
\end_layout

\begin_layout FragileFrame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Programming Paradigms of Julia 4: Subscoping
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Functions take the default values of their current scope.
\end_layout

\begin_layout Itemize
Variables defined in a higher scope 
\begin_inset Quotes eld
\end_inset

give their value
\begin_inset Quotes erd
\end_inset

 to lower scope by default
\end_layout

\begin_layout Itemize

\series bold
The highest scope is automatically global
\end_layout

\begin_deeper
\begin_layout Itemize
This is the single largest cause of slowdowns for first-time Julia users
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

x=5; y=7; #Defined globally
\end_layout

\begin_layout Plain Layout

function scopeTest(z)
\end_layout

\begin_layout Plain Layout

  x += z #Changes global value
\end_layout

\begin_layout Plain Layout

  y = Vector{Float64}(1) #Declares a variable, local scope
\end_layout

\begin_layout Plain Layout

  y[1] = 2 
\end_layout

\begin_layout Plain Layout

  return x + y + z
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout FragileFrame

\end_layout

\begin_layout Subsection
Project 6: Scoping Caution
\end_layout

\begin_layout FragileFrame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Project 6: Scoping Caution
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

function f1()
\end_layout

\begin_layout Plain Layout

  @parallel for i = 1:100
\end_layout

\begin_layout Plain Layout

    var = 10
\end_layout

\begin_layout Plain Layout

    if var < 100
\end_layout

\begin_layout Plain Layout

      var = var + 1
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

  end
\end_layout

\begin_layout Plain Layout

  var = 100 + 10
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

f1()
\end_layout

\begin_layout Plain Layout

function f2()
\end_layout

\begin_layout Plain Layout

  @parallel for i = 1:100
\end_layout

\begin_layout Plain Layout

    var = 10
\end_layout

\begin_layout Plain Layout

    if var < 100
\end_layout

\begin_layout Plain Layout

      var = var + 1
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

  end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

f2()
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout FragileFrame

\end_layout

\begin_layout Subsection
Quick Introduction to LLVM
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Quick Introduction to LLVM
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
LLVM is the compiler the Julia on top of
\end_layout

\begin_deeper
\begin_layout Itemize
It is an open source project that many other languages use
\end_layout

\end_deeper
\begin_layout Itemize
Many functionalities of Julia are developed via the LLVM
\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
Naitive LLVM compilation of CUDA kernals and Xeon Phi code will soon be
 part of Julia base
\end_layout

\end_deeper
\begin_layout Itemize

\color blue
You can check your LLVM code via @code_llvm, @code_native
\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
One thing to look for is automatic SIMD constructs
\end_layout

\begin_layout Itemize

\color blue
Also look out for 
\begin_inset Quotes eld
\end_inset

too many extra things
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Extra Projects
\end_layout

\begin_layout Subsection
Modeling Project: Logistic Curve
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Modeling Project: Logistic Curve (Medium)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The logistic difference equation is defined by the recursion
\begin_inset Formula 
\[
b_{n+1}=r*b_{n}(1-b_{n})
\]

\end_inset

 where 
\begin_inset Formula $b_{n}$
\end_inset

 is the number of bunnies at time 
\begin_inset Formula $n$
\end_inset

.
 Starting with 
\begin_inset Formula $b_{0}=.25$
\end_inset

, by around 400 iterations this will reach a steady state.
 This steady state (or steady periodic state) is dependent on 
\begin_inset Formula $r$
\end_inset

.
 Write a function which solves for the steady state(s) for each given 
\begin_inset Formula $r$
\end_inset

, and plot every state in the steady attractor for each 
\begin_inset Formula $r$
\end_inset

 (
\begin_inset Formula $x$
\end_inset

-axis is 
\begin_inset Formula $r$
\end_inset

, 
\begin_inset Formula $y=$
\end_inset

value seen in the attractor) using PyPlot.
 Take 
\begin_inset Formula $r\in\left(2.9,4\right)$
\end_inset


\end_layout

\begin_layout Standard
Optimize this function.
\end_layout

\end_deeper
\begin_layout Frame

\end_layout

\begin_layout Subsection
Modeling Solution
\end_layout

\begin_layout FragileFrame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Modeling Solution
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function logisticPlot()
\end_layout

\begin_layout Plain Layout

  tic()
\end_layout

\begin_layout Plain Layout

  r = 2.9:.00005:4; numAttract = 100;
\end_layout

\begin_layout Plain Layout

  steady = ones(length(r),1)*.25;
\end_layout

\begin_layout Plain Layout

  for i=1:400 ## Get to steady state
\end_layout

\begin_layout Plain Layout

    @devec steady = r.*steady.*(1-steady);
\end_layout

\begin_layout Plain Layout

  end
\end_layout

\begin_layout Plain Layout

  x = zeros(length(steady),numAttract);
\end_layout

\begin_layout Plain Layout

  x[:,1] = steady;
\end_layout

\begin_layout Plain Layout

  @simd for i=2:numAttract ## Grab values at the attractor
\end_layout

\begin_layout Plain Layout

    @inbounds @fastmath x[:,i] = r.*x[:,i-1].*(1-x[:,i-1]);
\end_layout

\begin_layout Plain Layout

  end
\end_layout

\begin_layout Plain Layout

  toc()
\end_layout

\begin_layout Plain Layout

  fig = figure(figsize=(20,10));
\end_layout

\begin_layout Plain Layout

  plot(collect(r),x,"b.",markersize=.06)
\end_layout

\begin_layout Plain Layout

  savefig("plot.png",dpi=300);
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

using PyPlot
\end_layout

\begin_layout Plain Layout

@time logisticPlot()
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout FragileFrame

\end_layout

\begin_layout FragileFrame

\end_layout

\begin_layout Subsection
Data Visualization Project
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Data Visualization and DataFrames Project (Easy)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Follow along with the Gadfly + RDatasets demo at:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/timholy/gadfly/blob/master/demo.md
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Frame

\end_layout

\begin_layout Frame

\end_layout

\begin_layout Subsection
HPC Multi-Node Parallelization
\end_layout

\begin_layout FragileFrame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
HPC Multi-Node Parallelization (Easy)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Use the job script to call a test.jl script on the cluster:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#!/bin/bash
\end_layout

\begin_layout Plain Layout

#$ -N jbtest
\end_layout

\begin_layout Plain Layout

#$ -q <CHOOSE A QUEUE>
\end_layout

\begin_layout Plain Layout

#$ -pe mpich 128
\end_layout

\begin_layout Plain Layout

#$ -cwd            		# Run in current directory
\end_layout

\begin_layout Plain Layout

module load julia/0.4.3
\end_layout

\begin_layout Plain Layout

julia --machinefile jbtest-pe_hostfile_mpich.$JOB_ID test.jl
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Make sure that all of the compute nodes are being used
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

hosts = @parallel for i=1:120
\end_layout

\begin_layout Plain Layout

       run(`hostname`) end
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\size small
Write a simple parallel loop (rand > .5 with (+) reduction), SSH into the
 nodes and use htop to check usage
\end_layout

\begin_layout Itemize

\size small
Information for other HPCs can be found here:
\size default
 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.stochasticlifestyle.com/multi-node-parallelism-in-julia-on-an-hpc/
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Internal Investigations Project
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Interal Investigations Project (Quick, but Hard)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Learn about the @code_native and @which macros here:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://sinews.siam.org/DetailsPage/tabid/607/ArticleID/744/Julia-A-Fast-Language-
for-Numerical-Computing.aspx
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Test the @code_llvm macro on some of your codes.
 What changes when you use @simd? Look for <Vector >s
\end_layout

\begin_layout Itemize
Try apropos, ?, @which to find functions and check dispatches
\end_layout

\begin_layout Itemize
On one of the functions previously written, use the fieldnames() function
 to find the function pointer
\end_layout

\end_deeper
\begin_layout Frame

\end_layout

\begin_layout Subsection
Modules and Packages
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Modules and Packages (Medium)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Wrap the functions from Project 4/5 into a module
\end_layout

\begin_layout Itemize
Export the functions in the module
\end_layout

\begin_layout Itemize
Import the module and test the functionality
\end_layout

\begin_layout Itemize
Generate a package via Pkg.generate(
\begin_inset Quotes eld
\end_inset

Name
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
Put the module into the package, test the package
\end_layout

\begin_layout Itemize
Setup the package to pre-compile during the first build
\end_layout

\end_deeper
\begin_layout Subsection
Language Bindings
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Language Bindings (Hard)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
C
\end_layout

\begin_deeper
\begin_layout Enumerate
Follow along here: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.stochasticlifestyle.com/using-julias-c-interface-utilize-c-libraries/
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
If GSL is not available, Write a Hello World script in C which takes in
 an array of numbers and also prints the numbers.
\end_layout

\begin_layout Enumerate
Write a Julia function which sorts the numbers, compile the function to
 a C function, and use the C calling interface to call the function from
 a C code
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Subsection
Language Bindings Continued
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Language Bindings Continued (Medium)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Python
\end_layout

\begin_deeper
\begin_layout Enumerate
Use the following package to import Python packages: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/stevengj/PyCall.jl
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
MATLAB
\end_layout

\begin_deeper
\begin_layout Enumerate
Check out the following: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/JuliaLang/MATLAB.jl
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Note that this requires you to NOT be on Windows
\end_layout

\begin_layout Enumerate
Test some of the examples on the Github demo.
\end_layout

\begin_layout Enumerate
For a more advanced introduction, try porting Finite Element Method code
 as described here: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.stochasticlifestyle.com/julia-ifem-1-mesh-generation-and-julias-type-sy
stem/
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
R
\end_layout

\begin_deeper
\begin_layout Enumerate
To call R with Julia, test the following package: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/lgautier/Rif.jl
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
To call Julia with R, test the following package: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/armgong/RJulia
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Data Saving and Serialization
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Data Saving and Serialization (Medium)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Try the HDF5 package for .jld and .mat files: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/JuliaLang/HDF5.jl
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Try the serialize() and deserialize() functions for high-performance serializati
on (note: the official mantra for future compatability is "people will try
 not to break the serialization format, but you shouldn't depend upon on
 it." Use .jld and .mat for long-term data storage)
\end_layout

\end_deeper
\begin_layout Section
Additional Topics
\end_layout

\begin_layout Subsection
Generated Functions
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Generated Functions (Hard)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Generated functions are Macros which have type information.
\end_layout

\begin_deeper
\begin_layout Itemize
More general than macros
\end_layout

\end_deeper
\begin_layout Itemize
Information can be found on the metaprogramming page:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://docs.julialang.org/en/release-0.4/manual/metaprogramming/
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Optimization / Machine Learning
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Optimization / Machine Learning (Medium)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
An extensive modeling framework for optimization is available via JuMP
\end_layout

\begin_deeper
\begin_layout Itemize
This package lets one easily write problems and switch out solvers to find
 the best solver method
\end_layout

\begin_layout Itemize
There are currently 13 available solvers
\end_layout

\begin_layout Itemize
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://jump.readthedocs.org/en/latest/
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Other interfaces are available via Ipopt, NLopt, etc.
\end_layout

\begin_layout Itemize
The homepage for the JuliaOpt group can be found here: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.juliaopt.org/
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
JuliaOpt has its own mailing list, Google Groups / Julia-opt
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
GPGPU / Xeon Phi Computing
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
GPGPU / Xeon Phi Computing (Medium)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
For tutorials on using the CUDA Runtime for GPGPU computing, see the following:
\end_layout

\begin_layout Itemize
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.stochasticlifestyle.com/julia-on-the-hpc-with-gpus/
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.stochasticlifestyle.com/multiple-gpu-on-the-hpc-with-julia/
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The group JuliaGPU has a repository of the available packages:
\end_layout

\begin_layout Itemize
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/JuliaGPU
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Users can be found here: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://gitter.im/JuliaGPU/meta
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Xeon Phi linking can be found here: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.stochasticlifestyle.com/interfacing-xeon-phi-via-julia/
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Native Xeon Phi linking can be found in the ParallelAccelerator.jl package
 (extremely new)
\end_layout

\end_deeper
\end_deeper
\end_body
\end_document
